Focus of This Fork
==================================

This fork of [Open-Xml-PowerTools](https://github.com/OpenXmlDev/Open-Xml-PowerTools) aims to

  * add DocumentComposer functionality (see below)
  * fix bugs that may not (yet) have been fixed upstream
  * target .NET 8.0 (stable) and 10.0 (preview) for cross-platform usage
  * otherwise track the upstream fork closely, supporting the same usage patterns and practices
 
The project was originally forked from OpenXmlDev's repository, but recently migrated to be
based on [Codeuctivity's fork](https://github.com/Codeuctivity/OpenXmlPowerTools) instead
because it is much more actively maintained.

Terminology (quick)
===================

- **Parent template**: the main DOCX on which you call `ComposeDocument`.
- **Child content**: DOCX content (document or template) that gets inserted into the parent.
- **Insert Id**: the identifier used to resolve child content (either a filename in "implicit" mode,
  or a key into the provided sources in "direct" and "indirect" modes).
- **Static vs dynamic insert**: a static insert is already-final DOCX content; a dynamic insert
  is itself a template that needs DocumentAssembler before insertion.

DocumentComposer
================
DocumentComposer is a wrapper around both `DocumentAssembler` and `DocumentBuilder`, allowing
features of each to be available to the other.

Traditionally, Open-Xml-PowerTools has provided
  * `DocumentAssembler` as a way to "assemble" a single DOCX based on a DOCX "template" + XML data
  * `DocumentBuilder` as a way "build" a single DOCX based on smaller DOCX 'building blocks'
  
Both of these tools are great, but they work quite differently from each other. Fundamentally...

  * `DocumentAssembler` entails embedding placeholders into a __Word-editable DOCX template__,
    to indicate where textual content is intended to be merged when generating a document.

  * `DocumentBuilder` entails __using C# code__ to specify how documents should be combined.
    - Code can specify a list of DOCX files to be concatenated into a single document, OR
    - Code can embed custom `<Insert>` XML elements into one DOCX file, and then provide
      additional DOCX files that correlate with each `<Insert>`.
      (Conceptually, this is _sort of_ like a template, in that there is a "parent" DOCX that
      indicates where insertions are meant to happen, but if saved, it would be unreadable in Word.)

In order to maximize backwards compatibility with both `DocumentAssembler` and `DocumentBuilder`,
we opted to create a new `DocumentComposer` wrapper to cleanly integrate the two. This approach entailed
some changes to `DocumentBuilder` and relatively minimal extensions to `DocumentAssembler`, which now:
  * recognizes new DA `<Insert>` metadata for designating insertion points
  * during assembly, DA `<Insert>` metadata is replaced with DocumentBuilder `<Insert>` element
  * assembly also reports what DA `<Insert>`s it encountered (for use in composition)
  * otherwise no impact or change to its existing functionality.

Existing code that relies on `DocumentAssembler` can very easily incorporate `DocumentComposer` by swapping out calls to
`DocumentAssembler.AssembleDocument` with calls to `DocumentComposer.ComposeDocument` -- the two have very closely
matching signatures. If the given template does not indicate any insertion points, `DocumentComposer` simply acts
as a thin wrapper around `DocumentAssembler`. However, if the template DOES contain insertion points,
`DocumentComposer` takes care of...

  1. assembling the parent template,
  2. assembling all the child content to be inserted (whether that is static or generated by additional assembly),
  3. performing the composition.
  
It also does interim assemblies and composition in RAM (without unnecessary creation of temp files on disk).

DocumentComposer facilitates several different **modes** of document composition. These modes differ by
  * composition method (whether via **insertion** or **concatenation**)
  * how composition "sources" (the building-blocks of DOCX content) are identified ("implicit", "direct" or "indirect")

Insertion w/ Implicit Sources
--------------------------------------------
In this mode, a "parent" DOCX template refers directly **(by file name)** to "child" files that are to be inserted.
Inserted ("child") DOCX files...

  * must be located in the same directory as the parent template
  * can be static (already fully defined) or dynamic (template-based, requiring their own assembly)

### Sample code for "implicit" sources:

```csharp
  var wmlTemplate = new WmlDocument("path/to/ParentTemplate.docx");
  var xmlData = XElement.Load("path/to/data.xml");

  var result = await DocumentComposer.ComposeDocument(wmlTemplate, xmlData);
  result.SaveAs("path/to/output.docx");
```

#### Notes:
  * In this model, sources are "implicit" because no list of sources needs to be explicitly provided as
    a 3rd argument to ComposeDocument (contrast with other modes below). Insert Ids are file names
    identifying child content.
  * If neither the parent template NOR any child files require DocumentAssembler, you may pass null for xmlData.

### Sample template illustrating use of 2 "implicit" sources:

In **ParentTemplate.docx**:

```md
This is a parent document, <# <Content Select="./Name"/> #>.¶
<# <Insert Id="InsertedStatic.docx"/> #>¶
<# <Insert Id="InsertedTemplate.docx" Select="."/> #>¶
This is the parent document again, <# <Content Select="./Name"/> #>.¶
```

#### Template notes:
  * An "Implicit" composition source means the filename of the DOCX to insert is inferred
    from the `Insert`'s `Id` attribute.
  * For this to work, the indicated filename must be in the same directory as the parent template DOCX file.
  * "InsertedStatic.docx" is assumed to be a **static** DOCX because no `Select` attribute was specified.
  * Because a `Select` attribute is present for the second insert, "InsertedTemplate.docx" will be assembled
    (using the data resulting from the `Select` attrib), and the resulting document inserted.


Insertion w/ "Direct" Sources
-----------------------------------------
In this mode of operation, a "parent" DOCX template identifies WHERE "child" DOCX content is to be inserted,
but the actual child content is passed in (as a `DocxSource`) rather than DocumentComposer looking for it on disk.
The `Id` attribute of the `<Insert>` element is now used as a key to look up the `DocxSource` within the list of
sources provided when calling ComposeDocument.

### Sample code to invoke ComposeDocument with "direct" sources:

```csharp
  var wmlTemplate = new WmlDocument("path/to/ParentTemplate.docx");
  var xmlData = XElement.Load("path/to/data.xml");
  var sources = new DocxSource[]
  {
    new DocxSource("path/to/StaticInsert.docx", "Insert1"),
    new TemplateSource("path/to/ChildTemplate.docx", xmlData, "Insert2")
  };
  var result = await DocumentComposer.ComposeDocument(wmlTemplate, xmlData, sources);
  result.SaveAs("path/to/output.docx");
```

#### Notes:
  * This model refers to sources as "direct" because
    (1) an explicit list of sources is provided in the 3rd argument to ComposeDocument, and
    (2) any `<Insert>` elements in ParentTemplate.docx refer to those sources **directly** by insert ID.

### Sample template illustrating "direct" sources:

In ParentTemplate.docx:

```md
This is a parent document, <# <Content Select="./Name"/> #>.¶
<# <Insert Id="Insert1"/> #>¶
<# <Insert Id="Insert2"/> #>¶
This is the parent document again, <# <Content Select="./Name"/> #>.¶
```

#### Template notes:
  * A "Direct" composition source means the Insert's `Id` attribute is used to look up the appropriate
    insert source from among those passed into ComposeDocument.
  * In this case, the specific type of source object passed into ComposeDocument is used to determine
    whether that source is static (`DocxSource`) or dynamic (`TemplateSource`).

This mode offers significantly more flexibility, but you must know (prior to calling ComposeDocument) which
source IDs your template refers to, so you can provide the necessary sources with your call.


Insertion w/ "Indirect" Sources
-------------------------------------------
In this mode of operation, the "parent" DOCX might not contain `<Insert>` elements at all, but rather,
it contains regular `<Content>` elements (which must be at block level). These `<Content>` elements
cause a lookup in the XML data, and that data then contains the actual Insert Id used to identify
a composition source.

### Sample code to invoke ComposeDocument with "indirect" sources /(same as above)/:

```csharp
  var wmlTemplate = new WmlDocument("path/to/ParentTemplate.docx");
  var xmlData = XElement.Load("path/to/data.xml");
  var sources = new DocxSource[]
  {
    new DocxSource("path/to/StaticInsert.docx", "Insert1"),
    new TemplateSource("path/to/ChildTemplate.docx", xmlData, "Insert2")
  };
  var result = await DocumentComposer.ComposeDocument(wmlTemplate, xmlData, sources);
  result.SaveAs("path/to/output.docx");
```

#### Notes:
  * this code is the same as the sample above for "direct" sources
  * The access is "indirect" because in this case, the template refers not "directly" to the insert Id,
    but rather to an intermediate value within the XML data that then points to the actual insert Id:

### Sample template showing "indirect" sources:

In ParentTemplate.docx:

```md
This is a parent document, <# <Content Select="./Name"/> #>.¶
<# <Content Select="./Indirect1"/> #>¶
<# <Content Select="./Indirect2"/> #>¶
This is the parent document again, <# <Content Select="./Name"/> #>.¶
```

### Sample data showing "indirect" sources
```xml
<?xml version="1.0" encoding="utf-8"?>
<Customer>
  <Name>Cheryl</Name>
  <Indirect1>oxpt://DocumentAssembler/insert/Insert1</Indirect1>
  <Indirect2>oxpt://DocumentAssembler/insert/Insert2</Indirect2>
</Customer>
```

Concatenation (Direct Sources)
------------------------------
Similar to the way DocumentBuilder 1.0 worked (via concatenation of documents, rather than insertion), except that
in addition to static DOCX sources, dynamic sources (created by process of document assembly) are also supported.


Future
======
  * planning to integrate support for **image insertion** into DocumentComposer, allowing for both static and
    potentially dynamically-generated images to be incorporated into assembled documents efficiently (i.e. without
    base64-encoding the image data and embedding them into the XML).
  
  * also researching feasibility of having DocumentAssembler (optionally) translate markdown tags in incoming XML
    data into native DOCX formatting codes when inserting content into templates.


Sponsorship
===========
OpenDocx (including its work on Open-Xml-PowerTools) is sponsored by [Knackly](https://knackly.io).
